# book: Ocaml from the very beginning

## names and functions

```ocaml
utop # let x = 20;;
val x : int = 20
─( 10:06:01 )─< command 16 >─────────────────────────────────────{ counter: 0 }─
utop # x*x*x;;
- : int = 8000
utop # let a = 500 in (let b = a*a in a+b);;
- : int = 250500
utop # let cube x = x*x*x;;
val cube : int -> int = <fun>
─( 10:08:52 )─< command 19 >─────────────────────────────────────{ counter: 0 }─
utop # cube 100;;
- : int = 1000000
utop # let neg x = if x < 0 then true else false;;
val neg : int -> bool = <fun>
─( 10:09:30 )─< command 21 >─────────────────────────────────────{ counter: 0 }─
utop # neg(-30);;
- : bool = true
utop # let rec factorial x = 
if x = 1 then 1
else x * factorial(x-1);;
val factorial : int -> int = <fun>
─( 10:10:47 )─< command 23 >─────────────────────────────────────{ counter: 0 }─
utop # factorial 4;;
- : int = 24
utop # let isvowel c =
match c with
'a' | 'e' | 'i' | 'o' | 'u' -> true
| _ -> false;;
val isvowel : char -> bool = <fun>
─( 10:12:12 )─< command 25 >─────────────────────────────────────{ counter: 0 }─
utop # isvowel 'a';;
- : bool = true
─( 10:14:48 )─< command 26 >─────────────────────────────────────{ counter: 0 }─
utop # isvowel 'x';;
- : bool = false
```

## making lists

```ocaml
─( 09:32:32 )─< command 1 >──────────────────────────────────────{ counter: 0 }─
utop # let l1 = [1;2];;
val l1 : int list = [1; 2]
─( 09:32:44 )─< command 2 >──────────────────────────────────────{ counter: 0 }─
utop # l1@[4;5;6] ;;
- : int list = [1; 2; 4; 5; 6]
─( 09:33:25 )─< command 3 >──────────────────────────────────────{ counter: 0 }─
utop # let isnil l = 
  match l with 
    [] -> true
    | _ -> false ;;
val isnil : 'a list -> bool = <fun>
─( 09:33:39 )─< command 4 >──────────────────────────────────────{ counter: 0 }─
utop # isnil l1 ;;
- : bool = false
utop # let rec length l =
  match l with 
    [] -> 0
    | h::t -> 1 + length t ;;
val length : 'a list -> int = <fun>
─( 09:34:42 )─< command 6 >──────────────────────────────────────{ counter: 0 }─
utop # length l1 ;;
- : int = 2
```

* in the last function length for the list, ```::``` is a destructor, in the code, ```h``` gets the head and ```t``` gets the tail of the list.

* ```<>``` is structural not-equal, while ```!=``` is physical not-equals.

* ```=``` is structural equality and ```==``` is physical equality.

## two different ways of thinking

```ocaml
utop # let rec append a b =
  match a with 
    [] -> b
    | h::t -> h :: append t b ;;
val append : 'a list -> 'a list -> 'a list = <fun>
─( 09:36:40 )─< command 8 >──────────────────────────────────────{ counter: 0 }─
utop # let l2 = [2; 3; 4] ;;
val l2 : int list = [2; 3; 4]
─( 09:46:55 )─< command 9 >──────────────────────────────────────{ counter: 0 }─
utop # append [] l2 ;;
- : int list = [2; 3; 4]
─( 09:47:16 )─< command 10 >─────────────────────────────────────{ counter: 0 }─
utop # append l1 l2 ;;
- : int list = [1; 2; 2; 3; 4]
```

* in the above example, the thinking is as follows: look at the first list. if it is empty, return the second list. otherwise, pull apart the first list, looking at its head and tail. make a recursive call to append the tail to the second list, and then cons the head onto the result. return this.

* another way of thinking: we can consider each match case to be an independent statement of truth, thinking the same way about the whole function. The empty list appended to another list is that list. Otherwise, the first list is non-empty, so it has a head and a tail. Call them h and t. Clearly append (h :: t) b is equal to h :: append t b. Since this reduces the problem size, progress is made.

## sorting

```ocaml
utop # let rec insert x l =
  match l with
    [] -> [x]
    | h::t ->
      if x <= h
        then x :: h :: t
        else h :: insert x t ;;
val insert : 'a -> 'a list -> 'a list = <fun>
─( 09:47:34 )─< command 12 >─────────────────────────────────────{ counter: 0 }─
utop # let rec sort l =
  match l with 
    [] -> []
    | h::t -> insert h (sort t) ;;
val sort : 'a list -> 'a list = <fun>
─( 09:53:01 )─< command 13 >─────────────────────────────────────{ counter: 0 }─
utop # insert 3 [1;1;2;3;5;9] ;;
- : int list = [1; 1; 2; 3; 3; 5; 9]
```

another version of merge two list and sort at the same time:

```ocaml
─( 10:02:16 )─< command 1 >──────────────────────────────────────{ counter: 0 }─
utop # #use "bk_merge.ml" ;;
val merge : 'a list -> 'a list -> 'a list = <fun>
─( 10:02:28 )─< command 2 >──────────────────────────────────────{ counter: 0 }─
utop # let l1 = [1; 2; 3];;
val l1 : int list = [1; 2; 3]
─( 10:02:55 )─< command 3 >──────────────────────────────────────{ counter: 0 }─
utop # merge l1 l1 ;;
- : int list = [1; 1; 2; 2; 3; 3]
```

## functions upon functions

* double: double every element in the list

```ocaml
─( 10:22:07 )─< command 0 >──────────────────────────────────────{ counter: 0 }─
utop # #use "bk_double.ml" ;;
val double : int list -> int list = <fun>
─( 10:22:07 )─< command 1 >──────────────────────────────────────{ counter: 0 }─
utop # double [1; 2; 3] ;;
- : int list = [2; 4; 6]
```

* evens: check if an element in the list is an even number

```ocaml
utop # #use "bk_evens.ml" ;;
val evens : int list -> bool list = <fun>
─( 10:22:29 )─< command 3 >──────────────────────────────────────{ counter: 0 }─
utop # evens [1; 2; 3; 4] ;;
- : bool list = [false; true; false; true]
```

* map and halve

```ocaml
utop # #use "bk_map.ml" ;;
val map : ('a -> 'b) -> 'a list -> 'b list = <fun>
─( 10:25:36 )─< command 5 >──────────────────────────────────────{ counter: 0 }─
utop # let halve x = x /2 ;;
val halve : int -> int = <fun>
─( 10:28:46 )─< command 6 >──────────────────────────────────────{ counter: 0 }─
utop # map halve [10; 20; 30; 40];;
- : int list = [5; 10; 15; 20]
```

* evens

```ocaml
utop # let is_even x = x mod 2 = 0 ;;
val is_even : int -> bool = <fun>
─( 10:29:34 )─< command 8 >──────────────────────────────────────{ counter: 0 }─
utop # let evens l = map is_even l ;;
val evens : int list -> bool list = <fun>
─( 10:30:38 )─< command 9 >──────────────────────────────────────{ counter: 0 }─
utop # let evens l = map (fun x -> x mod 2 = 0) l ;;
val evens : int list -> bool list = <fun>
```

the last evens function has an anonymous function inside.

